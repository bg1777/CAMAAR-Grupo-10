=== DB SCHEMA ===
# This file is auto-generated from the current state of the database. Instead
# of editing this file, please use the migrations feature of Active Record to
# incrementally modify your database, and then regenerate this schema definition.
#
# This file is the source Rails uses to define your schema when running `bin/rails
# db:schema:load`. When creating a new database, `bin/rails db:schema:load` tends to
# be faster and is potentially less error prone than running all of your
# migrations from scratch. Old migrations may fail to apply correctly if those
# migrations use external dependencies or application code.
#
# It's strongly recommended that you check this file into your version control system.

ActiveRecord::Schema[8.0].define(version: 2025_12_08_031925) do
  create_table "class_members", force: :cascade do |t|
    t.integer "user_id", null: false
    t.integer "klass_id", null: false
    t.string "role"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["klass_id"], name: "index_class_members_on_klass_id"
    t.index ["user_id"], name: "index_class_members_on_user_id"
  end

  create_table "form_answers", force: :cascade do |t|
    t.integer "form_response_id", null: false
    t.integer "form_template_field_id", null: false
    t.text "answer"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["form_response_id"], name: "index_form_answers_on_form_response_id"
    t.index ["form_template_field_id"], name: "index_form_answers_on_form_template_field_id"
  end

  create_table "form_responses", force: :cascade do |t|
    t.integer "form_id", null: false
    t.integer "user_id", null: false
    t.datetime "submitted_at"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["form_id"], name: "index_form_responses_on_form_id"
    t.index ["user_id"], name: "index_form_responses_on_user_id"
  end

  create_table "form_template_fields", force: :cascade do |t|
    t.integer "form_template_id", null: false
    t.string "field_type"
    t.string "label"
    t.boolean "required"
    t.json "options"
    t.integer "position"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["form_template_id"], name: "index_form_template_fields_on_form_template_id"
  end

  create_table "form_templates", force: :cascade do |t|
    t.string "name"
    t.text "description"
    t.integer "user_id", null: false
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["user_id"], name: "index_form_templates_on_user_id"
  end

  create_table "forms", force: :cascade do |t|
    t.integer "form_template_id", null: false
    t.integer "klass_id", null: false
    t.string "title"
    t.text "description"
    t.datetime "due_date"
    t.integer "status"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["form_template_id"], name: "index_forms_on_form_template_id"
    t.index ["klass_id"], name: "index_forms_on_klass_id"
  end

  create_table "klasses", force: :cascade do |t|
    t.string "code"
    t.string "name"
    t.string "semester"
    t.text "description"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end

  create_table "users", force: :cascade do |t|
    t.string "email", default: "", null: false
    t.string "encrypted_password", default: "", null: false
    t.string "reset_password_token"
    t.datetime "reset_password_sent_at"
    t.datetime "remember_created_at"
    t.string "name", null: false
    t.integer "role", default: 0
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.string "matricula"
    t.string "curso"
    t.string "formacao"
    t.string "ocupacao"
    t.index ["email"], name: "index_users_on_email", unique: true
    t.index ["reset_password_token"], name: "index_users_on_reset_password_token", unique: true
  end

  add_foreign_key "class_members", "klasses"
  add_foreign_key "class_members", "users"
  add_foreign_key "form_answers", "form_responses"
  add_foreign_key "form_answers", "form_template_fields"
  add_foreign_key "form_responses", "forms"
  add_foreign_key "form_responses", "users"
  add_foreign_key "form_template_fields", "form_templates"
  add_foreign_key "form_templates", "users"
  add_foreign_key "forms", "form_templates"
  add_foreign_key "forms", "klasses"
end


=== ROUTES ===
# config/routes.rb

Rails.application.routes.draw do
  devise_for :users, skip: [:registrations]
  
  root "home#index"
  
  namespace :admin do
    root "dashboard#index"
    resources :users
    resources :imports, only: [:index] do
      collection do
        post :import_klasses
      end
    end
    
    # Form Templates
    resources :form_templates do
      resources :form_template_fields, only: [:create, :update, :destroy]
    end
    
    # Forms
    resources :forms do
      member do
        patch :publish
        patch :close
        get :view_response
      end
    end
  end

  # Student namespace
  namespace :student do
    root "dashboard#index"
    resources :forms, only: [:index, :show] do
      member do
        get :answer
        post :submit_answer
      end
    end
  end
  
  get "home", to: "home#index"
end


=== MODELS ===

--- app/models/class_member.rb ---
# app/models/class_member.rb

class ClassMember < ApplicationRecord
  # Associações
  belongs_to :user
  belongs_to :klass

  # Validações
  validates :user_id, uniqueness: { scope: :klass_id, message: 'já está inscrito nesta turma' }
  validates :role, presence: true, inclusion: { in: %w(dicente docente), message: 'deve ser dicente ou docente' }
end
--- app/models/form.rb ---
# app/models/form.rb

class Form < ApplicationRecord
  belongs_to :form_template
  belongs_to :klass
  has_many :form_responses, dependent: :destroy

  validates :form_template_id, presence: true
  validates :klass_id, presence: true
  validates :title, presence: true

  enum :status, { draft: 0, published: 1, closed: 2 }
  
  # Definir status padrão
  before_create :set_default_status

  # Retorna todos os alunos da turma que ainda não responderam o formulário
  def pending_responses
    klass.students - form_responses.map(&:user)
  end

  # Retorna alunos que já responderam
  def completed_responses
    form_responses.map(&:user)
  end

  private

  def set_default_status
    self.status ||= :draft
  end
end

--- app/models/form_answer.rb ---
# app/models/form_answer.rb

class FormAnswer < ApplicationRecord
  belongs_to :form_response
  belongs_to :form_template_field

  validates :form_response_id, presence: true
  validates :form_template_field_id, presence: true
  validates :answer, presence: true
end
--- app/models/form_response.rb ---
# app/models/form_response.rb - CORRIGIDO

class FormResponse < ApplicationRecord
  belongs_to :form
  belongs_to :user
  has_many :form_answers, dependent: :destroy

  validates :form_id, presence: true
  validates :user_id, presence: true
  validates :user_id, uniqueness: { scope: :form_id, message: 'já respondeu este formulário' }

  accepts_nested_attributes_for :form_answers

  def completed?
    submitted_at.present?
  end

  def pending?
    !completed?
  end

  # Criar form_answers para todos os campos do template
  def build_answers_for_fields
    form.form_template.form_template_fields.order(:position).each do |field|
      unless form_answers.exists?(form_template_field_id: field.id)
        form_answers.build(form_template_field: field, answer: '')
      end
    end
  end

  # Marcar como submetido
  def submit!
    update(submitted_at: Time.current)
  end
end
--- app/models/form_template.rb ---
# app/models/form_template.rb

class FormTemplate < ApplicationRecord
  belongs_to :user
  has_many :form_template_fields, dependent: :destroy
  has_many :forms, dependent: :destroy

  validates :name, presence: true
  validates :description, presence: true
  validates :user_id, presence: true

  accepts_nested_attributes_for :form_template_fields, allow_destroy: true
end
--- app/models/form_template_field.rb ---
# app/models/form_template_field.rb

class FormTemplateField < ApplicationRecord
  belongs_to :form_template
  has_many :form_answers, dependent: :destroy
  
  # Valores válidos para field_type
  VALID_FIELD_TYPES = %w(text textarea email number date select radio checkbox).freeze
  
  validates :form_template_id, presence: true
  validates :label, presence: true
  validates :field_type, presence: true, inclusion: { in: VALID_FIELD_TYPES }
  validates :position, presence: true, numericality: { only_integer: true }
  
  # Validar options apenas para tipos que precisam
  validates :options, presence: true, if: :requires_options?
  
  private
  
  def requires_options?
    ['select', 'radio', 'checkbox'].include?(field_type)
  end
end

--- app/models/klass.rb ---
# app/models/klass.rb

class Klass < ApplicationRecord
  # Associações
  has_many :class_members, dependent: :destroy
  has_many :users, through: :class_members
  has_many :forms, dependent: :destroy

  # Validações
  validates :code, presence: true, uniqueness: true
  validates :name, presence: true
  validates :semester, presence: true

  # Scopes
  scope :active, -> { order(semester: :desc) }

  # Métodos úteis
  def students
    class_members.where(role: 'dicente').map(&:user)
  end

  def teachers
    class_members.where(role: 'docente').map(&:user)
  end
end
--- app/models/user.rb ---
# app/models/user.rb

class User < ApplicationRecord
  devise :database_authenticatable,
         :recoverable, :validatable

  enum :role, { user: 0, admin: 1 }

  # Associações
  has_many :class_members, dependent: :destroy
  has_many :klasses, through: :class_members
  has_many :form_templates, dependent: :destroy
  has_many :form_responses, dependent: :destroy

  # Validações
  validates :name, presence: true
  validates :email, presence: true, uniqueness: true

  # Métodos auxiliares
  def admin?
    role == 'admin'
  end

  def user?
    role == 'user'
  end

  # Formulários pendentes (não respondidos)
  def pending_forms
    Form
      .where(klass_id: klasses.pluck(:id), status: :published)
      .where.not(
        id: form_responses.where.not(submitted_at: nil).pluck(:form_id)
      )
  end

  # Formulários já respondidos
  def completed_forms
    Form
      .where(id: form_responses.where.not(submitted_at: nil).pluck(:form_id))
  end
end

=== CONTROLLERS - ADMIN ===

--- app/controllers/admin/dashboard_controller.rb ---
# app/controllers/admin/dashboard_controller.rb

module Admin
  class DashboardController < ApplicationController
    before_action :authenticate_user!
    before_action :check_admin
    
    def index
      @users = User.all
      @total_users = User.count
      @admin_count = User.where(role: :admin).count
    end
    
    private
    
    def check_admin
      redirect_to root_path, alert: 'Acesso negado!' unless current_user.admin?
    end
  end
end

--- app/controllers/admin/form_templates_controller.rb ---
# app/controllers/admin/form_templates_controller.rb

module Admin
  class FormTemplatesController < ApplicationController
    before_action :authenticate_user!
    before_action :check_admin
    before_action :set_form_template, only: [:show, :edit, :update, :destroy]

    def index
      @form_templates = current_user.form_templates.order(created_at: :desc)
    end

    def show
    end

    def new
      @form_template = FormTemplate.new
      @form_template.form_template_fields.build  # ← Apenas 1 campo
    end

    def create
      @form_template = current_user.form_templates.build(form_template_params)

      if @form_template.save
        redirect_to admin_form_template_path(@form_template), notice: 'Template criado com sucesso!'
      else
        render :new, status: :unprocessable_entity
      end
    end

    def edit
      # Se não tiver campos, adiciona 1
      @form_template.form_template_fields.build if @form_template.form_template_fields.empty?
    end

    def update
      if @form_template.update(form_template_params)
        redirect_to admin_form_template_path(@form_template), notice: 'Template atualizado com sucesso!'
      else
        render :edit, status: :unprocessable_entity
      end
    end

    def destroy
      @form_template.destroy
      redirect_to admin_form_templates_url, notice: 'Template deletado com sucesso!'
    end

    private

    def set_form_template
      @form_template = FormTemplate.find(params[:id])
    end

    def form_template_params
      params.require(:form_template).permit(
        :name, :description,
        form_template_fields_attributes: [:id, :field_type, :label, :required, :options, :position, :_destroy]
      )
    end

    def check_admin
      redirect_to root_path, alert: 'Acesso negado!' unless current_user.admin?
    end
  end
end

--- app/controllers/admin/forms_controller.rb ---
# app/controllers/admin/forms_controller.rb

module Admin
  class FormsController < ApplicationController
    before_action :authenticate_user!
    before_action :check_admin
    before_action :set_form, only: [:show, :edit, :update, :destroy, :publish, :close, :view_response]
    before_action :set_form_response, only: [:view_response]

    def index
      @forms = Form.all.order(created_at: :desc)
    end

    def show
      @pending_count = @form.pending_responses.count
      @completed_count = @form.completed_responses.count
    end

    def new
      @form = Form.new
      @form_templates = FormTemplate.all
      @klasses = Klass.all
    end

    def create
      template = FormTemplate.find(form_params[:form_template_id])
      klass = Klass.find(form_params[:klass_id])
      
      @form = Form.new(
        form_template: template,
        klass: klass,
        title: form_params[:title],
        description: form_params[:description],
        due_date: form_params[:due_date],
        status: :draft
      )

      if @form.save
        redirect_to admin_form_path(@form), notice: 'Formulário criado com sucesso!'
      else
        @form_templates = FormTemplate.all
        @klasses = Klass.all
        render :new, status: :unprocessable_entity
      end
    end

    def edit
      @form_templates = FormTemplate.all
      @klasses = Klass.all
    end

    def update
      if @form.update(form_params)
        redirect_to admin_form_path(@form), notice: 'Formulário atualizado com sucesso!'
      else
        @form_templates = FormTemplate.all
        @klasses = Klass.all
        render :edit, status: :unprocessable_entity
      end
    end

    def destroy
      @form.destroy
      redirect_to admin_forms_url, notice: 'Formulário deletado com sucesso!'
    end

    def publish
      if @form.update(status: :published)
        redirect_to admin_form_path(@form), notice: 'Formulário publicado com sucesso!'
      else
        redirect_to admin_form_path(@form), alert: 'Erro ao publicar formulário'
      end
    end

    def close
      if @form.update(status: :closed)
        redirect_to admin_form_path(@form), notice: 'Formulário fechado com sucesso!'
      else
        redirect_to admin_form_path(@form), alert: 'Erro ao fechar formulário'
      end
    end

    def view_response
      # @form_response já é setado pelo before_action
    end

    private

    def set_form
      @form = Form.find(params[:id])
    end

    def set_form_response
      @form_response = FormResponse.find(params[:response_id])
    end

    def form_params
      params.require(:form).permit(:form_template_id, :klass_id, :title, :description, :due_date, :status)
    end

    def check_admin
      redirect_to root_path, alert: 'Acesso negado!' unless current_user.admin?
    end
  end
end

--- app/controllers/admin/imports_controller.rb ---
# app/controllers/admin/imports_controller.rb

module Admin
  class ImportsController < ApplicationController
    before_action :authenticate_user!
    before_action :check_admin

    def index
      @total_klasses = Klass.count
      @total_users = User.where(role: :user).count
    end

    def import_klasses
      if params[:file].blank?
        redirect_to admin_imports_path, alert: 'Por favor, selecione um arquivo'
        return
      end

      file = params[:file]
      
      # Validar tipo de arquivo
      unless file.content_type == 'application/json' || file.original_filename.end_with?('.json')
        redirect_to admin_imports_path, alert: 'Por favor, envie um arquivo JSON válido'
        return
      end

      # Executar importação
      service = ImportService.new(file.path)
      result = service.import_klasses

      if result[:success]
        message = "✅ #{result[:imported]} turma(s) importada(s) com sucesso!"
        
        if result[:errors].present?
          message += "\n\n⚠️ Aviso: #{result[:errors].count} erro(s) durante importação:"
          result[:errors].each { |error| message += "\n• #{error}" }
          redirect_to admin_imports_path, alert: message
        else
          redirect_to admin_imports_path, notice: message
        end
      else
        redirect_to admin_imports_path, alert: "❌ Erro na importação: #{result[:error]}"
      end
    end

    private

    def check_admin
      redirect_to root_path, alert: 'Acesso negado!' unless current_user.admin?
    end
  end
end
--- app/controllers/admin/users_controller.rb ---
# app/controllers/admin/users_controller.rb

module Admin
  class UsersController < ApplicationController
    before_action :authenticate_user!
    before_action :check_admin
    before_action :set_user, only: [:show, :edit, :update, :destroy]
    
    def index
      @users = User.all
    end
    
    def show
    end
    
    def edit
    end
    
    def update
      if @user.update(user_params)
        redirect_to admin_users_path, notice: 'Usuário atualizado com sucesso'
      else
        render :edit, status: :unprocessable_entity
      end
    end

    def destroy
      @user.destroy
      redirect_to admin_users_path, notice: 'Usuário deletado com sucesso'
    end

    private

    def set_user
      @user = User.find(params[:id])
    end

    def user_params
      params.require(:user).permit(:name, :email, :role)
    end

    def check_admin
      redirect_to root_path, alert: 'Acesso negado!' unless current_user.admin?
    end
  end
end


=== CONTROLLERS - STUDENT ===

--- app/controllers/student/forms_controller.rb ---
# app/controllers/student/forms_controller.rb - CORRIGIDO

module Student
  class FormsController < ApplicationController
    before_action :authenticate_user!
    before_action :check_student
    before_action :set_form, only: [:show, :answer, :submit_answer]
    before_action :check_form_accessible, only: [:show, :answer, :submit_answer]

    def index
      @pending_forms = current_user.pending_forms.order(due_date: :asc)
      @completed_forms = current_user.completed_forms.order(created_at: :desc)
    end

    def show
      @form_response = @form.form_responses.find_by(user: current_user)
      @form_response ||= FormResponse.new(form: @form, user: current_user)
    end

    def answer
      @form_response = @form.form_responses.find_by(user: current_user)

      if @form_response.nil?
        @form_response = FormResponse.new(form: @form, user: current_user)
        @form_response.save(validate: false)
        @form_response.build_answers_for_fields
        @form_response.save(validate: false)
      end

      @form_response.reload

      # Se não há respostas, criar agora
      if @form_response.form_answers.empty?
        @form_response.build_answers_for_fields
        @form_response.save(validate: false)
      end
    end

    def submit_answer
      @form_response = @form.form_responses.find_by(user: current_user)

      if @form_response.nil?
        redirect_to student_form_path(@form), alert: 'Resposta não encontrada'
        return
      end

      if update_answers && @form_response.submit!
        redirect_to root_path, notice: 'Formulário respondido com sucesso!'
      else
        redirect_to answer_student_form_path(@form), alert: 'Erro ao salvar respostas'
      end
    end

    private

    def set_form
      @form = Form.find(params[:id])
    end

    def check_student
      redirect_to admin_root_path if current_user.admin?
    end

    def check_form_accessible
      unless current_user.klasses.include?(@form.klass) && @form.published?
        redirect_to root_path, alert: 'Acesso negado a este formulário'
      end
    end

    def update_answers
      form_answers_params = params.require(:form_response).permit(form_answers_attributes: [:id, :answer])
      @form_response.update(form_answers_params)
    end
  end
end

=== APPLICATION CONTROLLER ===
class ApplicationController < ActionController::Base
  # Only allow modern browsers supporting webp images, web push, badges, import maps, CSS nesting, and CSS :has.
  allow_browser versions: :modern
end


=== SERVICES ===

--- app/services/import_service.rb ---
# app/services/import_service.rb

class ImportService
  attr_reader :file_path, :imported_count, :errors

  def initialize(file_path)
    @file_path = file_path
    @imported_count = 0
    @errors = []
  end

  # Importa turmas com seus estudantes
  def import_klasses
    data = parse_json_file

    data.each do |klass_data|
      import_single_klass(klass_data)
    end

    { success: true, imported: @imported_count, errors: @errors }
  rescue StandardError => e
    { success: false, error: e.message, imported: @imported_count, errors: @errors }
  end

  private

  def parse_json_file
    JSON.parse(File.read(@file_path))
  rescue JSON::ParserError => e
    raise "Erro ao ler arquivo JSON: #{e.message}"
  rescue Errno::ENOENT
    raise "Arquivo não encontrado: #{@file_path}"
  end

  def import_single_klass(klass_data)
    klass = find_or_create_klass(klass_data)
    
    # Importar estudantes
    import_students(klass, klass_data['dicente'])
    
    @imported_count += 1
  rescue StandardError => e
    @errors << "Erro ao importar turma #{klass_data['code']}: #{e.message}"
  end

  def find_or_create_klass(klass_data)
    klass_info = klass_data['class']
    
    Klass.find_or_create_by(code: klass_data['code']) do |klass|
      klass.name = klass_data['name']
      klass.semester = klass_info['semester']
      klass.description = "Turma #{klass_info['classCode']} - #{klass_info['time']}"
    end
  end

  def import_students(klass, students_data)
    return unless students_data.present?

    students_data.each do |student_data|
      import_single_student(klass, student_data, 'dicente')
    end
  end

  def import_single_student(klass, student_data, role)
    user = find_or_create_user(student_data)
    
    ClassMember.find_or_create_by(user: user, klass: klass) do |cm|
      cm.role = role
    end
  rescue StandardError => e
    @errors << "Erro ao importar estudante #{student_data['nome']}: #{e.message}"
  end

  def find_or_create_user(user_data)
    user = User.find_by(email: user_data['email'])
    
    if user.present?
      return user
    end

    # Usa matrícula como senha (Opção A)
    password = user_data['matricula']

    user = User.new(
      email: user_data['email'],
      name: user_data['nome'],
      matricula: user_data['matricula'],
      curso: user_data['curso'],
      formacao: user_data['formacao'],
      ocupacao: user_data['ocupacao'],
      password: password,
      password_confirmation: password,
      role: :user
    )

    if user.save
      user
    else
      raise "Erro ao salvar usuário #{user_data['email']}: #{user.errors.full_messages.join(', ')}"
    end
  end
end

=== MIGRATIONS ===

--- db/migrate/20251207235542_devise_create_users.rb ---
# frozen_string_literal: true


class DeviseCreateUsers < ActiveRecord::Migration[8.0]
  def change
    create_table :users do |t|
      ## Database authenticatable
      t.string :email,              null: false, default: ""
      t.string :encrypted_password, null: false, default: ""


      ## Recoverable
      t.string   :reset_password_token
      t.datetime :reset_password_sent_at


      ## Rememberable
      t.datetime :remember_created_at


      ## Trackable
      # t.integer  :sign_in_count, default: 0, null: false
      # t.datetime :current_sign_in_at
      # t.datetime :last_sign_in_at
      # t.string   :current_sign_in_ip
      # t.string   :last_sign_in_ip


      ## Confirmable
      # t.string   :confirmation_token
      # t.datetime :confirmed_at
      # t.datetime :confirmation_sent_at
      # t.string   :unconfirmed_email # Only if using reconfirmable


      ## Lockable
      # t.integer  :failed_attempts, default: 0, null: false # Only if lock strategy is :failed_attempts
      # t.string   :unlock_token # Only if unlock strategy is :email or :both
      # t.datetime :locked_at

      ## Custom fields
      t.string :name, null: false
      t.integer :role, default: 0  # 0: user, 1: admin

      t.timestamps null: false
    end


    add_index :users, :email,                unique: true
    add_index :users, :reset_password_token, unique: true
    # add_index :users, :confirmation_token,   unique: true
    # add_index :users, :unlock_token,         unique: true
  end
end
--- db/migrate/20251208005928_create_klasses.rb ---
class CreateKlasses < ActiveRecord::Migration[8.0]
  def change
    create_table :klasses do |t|
      t.string :code
      t.string :name
      t.string :semester
      t.text :description

      t.timestamps
    end
  end
end

--- db/migrate/20251208005929_create_class_members.rb ---
class CreateClassMembers < ActiveRecord::Migration[8.0]
  def change
    create_table :class_members do |t|
      t.references :user, null: false, foreign_key: true
      t.references :klass, null: false, foreign_key: true
      t.string :role

      t.timestamps
    end
  end
end

--- db/migrate/20251208005930_add_fields_to_users.rb ---
class AddFieldsToUsers < ActiveRecord::Migration[8.0]
  def change
    add_column :users, :matricula, :string
    add_column :users, :curso, :string
    add_column :users, :formacao, :string
    add_column :users, :ocupacao, :string
  end
end

--- db/migrate/20251208031921_create_form_templates.rb ---
class CreateFormTemplates < ActiveRecord::Migration[8.0]
  def change
    create_table :form_templates do |t|
      t.string :name
      t.text :description
      t.references :user, null: false, foreign_key: true

      t.timestamps
    end
  end
end

--- db/migrate/20251208031922_create_form_template_fields.rb ---
class CreateFormTemplateFields < ActiveRecord::Migration[8.0]
  def change
    create_table :form_template_fields do |t|
      t.references :form_template, null: false, foreign_key: true
      t.string :field_type
      t.string :label
      t.boolean :required
      t.json :options
      t.integer :position

      t.timestamps
    end
  end
end

--- db/migrate/20251208031923_create_forms.rb ---
class CreateForms < ActiveRecord::Migration[8.0]
  def change
    create_table :forms do |t|
      t.references :form_template, null: false, foreign_key: true
      t.references :klass, null: false, foreign_key: true
      t.string :title
      t.text :description
      t.datetime :due_date
      t.integer :status

      t.timestamps
    end
  end
end

--- db/migrate/20251208031924_create_form_responses.rb ---
class CreateFormResponses < ActiveRecord::Migration[8.0]
  def change
    create_table :form_responses do |t|
      t.references :form, null: false, foreign_key: true
      t.references :user, null: false, foreign_key: true
      t.datetime :submitted_at

      t.timestamps
    end
  end
end

--- db/migrate/20251208031925_create_form_answers.rb ---
class CreateFormAnswers < ActiveRecord::Migration[8.0]
  def change
    create_table :form_answers do |t|
      t.references :form_response, null: false, foreign_key: true
      t.references :form_template_field, null: false, foreign_key: true
      t.text :answer

      t.timestamps
    end
  end
end
